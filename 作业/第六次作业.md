## <center>第六次作业</center>

### <center>一、算法分析题 </center>

#### 6-1 0-1背包问题的栈式分支限界法

##### 问题表达

对于给定的$n$个物体与一个背包，假设第$i$个物体的重量为$w_i$，价值为$v_i$，背包总容量为$c$。令$\vec x=(x_1, x_2, ..., x_n)$为其解集空间，$x_i\in \{0, 1\}$代表是否装入第$i$个物体，则其解集空间为子集树。问题可表达为
$$
\max \sum_{i=1}^nx_iv_i\\s.t.\left\{\begin{array}\\\sum_{i=1}^nx_iw_i\le c\\x_i \in \{0, 1\}\end{array}\right.
$$

##### 算法

首先将根节点加入活结点列表并作为扩展结点，对于活结点列表，如果为空则输出最优解，否则判断左儿子节点是否为可行节点，可行则将其加入活结点列表。之后判断右儿子节点，由于右儿子节点肯定为可行节点，判断右儿子节点的最大可能价值是否大于最优价值，大于则加入活结点列表。之后从活结点列表中按照栈式后进先出的原则选取下一个节点。

##### 伪代码

```c++
while (i != n+1) {  // 非叶结点 
    // 检查当前扩展结点的左儿子结点 
    Typew wt = cw + w[i];
    if (wt <= c) {  
        // 左儿子结点为可行结点 
        if (cp+p[i] > bestp) 
            bestp = cp+p[i]; 
        AddLiveNode(up, cp+p[i], cw+w[i], true, i+1); 
    } 
    up = Bound(i+1); 
    // 检查当前扩展结点的右儿子结点 
    if (up >= bestp) // 右子树可能含最优解 
        AddLiveNode(up, cp, cw, false, i+1); 
    // 按照LIFO的原则选取下一个扩展结点
}
```

##### 区别

栈式分支限界法与回溯法主要的区别在于对当前扩展结点的扩展方式不同，栈式分支界限法每个节点只扩展一次，并一次性产生所有子节点，二回溯法每个节点可多次扩展直到子节点扩展完。

### <center>二、算法设计题 </center>

#### 6-1 最小长度电路板排列问题

##### 问题表达

由于此问题为求所给定$N$块电路板的最佳排列，即解空间为排列树。令解向量为$\vec{x}=(x_1, x_2, ..., x_n)$，$x_i\in\{1, 2, 3, ..., n\}$，$\vec{x}$为$\{1, 2, 3,...,n\}$的一个排列。对于一个特定排列$\vec{x}$及连接块$N_k$，设$f_k(\vec{x})=\max_{x_i,x_j\in N_k}\{|i-j|\}$为此时连接块的最大长度，则搜索目标为
$$
\min_{\vec{x}}\{\max_k\{f_k(\vec{x})\}\}
$$

##### 算法步骤

 电路板排列问题的解空间是一颗排列树。采用队列式分支限界法找出所给电路板的最小长度排列。算法采用队列，每一个的节点$node$包含域$x$，表示节点所相应的电路板排列；$s$表示该节点已确定的电路板排列$x[1:s]$；$cd$表示当前最大长度。

   算法开始时，将排列树的根结点置为当前扩展结点。在do-while循环体内算法依次从队列中取出结点作为当前扩展结点。算法将当前扩展节点分两种情形处理：

   1)首先考虑$s=n-1$的情形，当前扩展结点是排列树中的一个叶结点的父结点。$x$表示相应于该叶结点的电路板排列。计算出与$x$相应的最大长度并在必要时更新当前最优值和相应的当前最优解。

   2)当$s<n-1$时，算法依次产生当前扩展结点的所有儿子结点。对于当前扩展结点的每一个儿子结点$node$，计算出其相应的最大长度$node.cd$。当$node.cd<bestd$时，将该儿子结点$node$插入到活结点队列中。

##### 伪代码

```c++
int search(){
    queue<Node> q;
    Node enode;
    while(true){
        if(enode.dep == n-1){ //仅一个儿子结点，已经排完n-1个电路板，更新最优值
            if(enode.cd < bestd)
                bestd = enode.cd; 
        }
        else{
            int cur = enode.dep + 1;
            for(i=enode.dep+1; i<=n; i++){  //产生当前扩展结点的所有儿子结点
                now.cd = now.len();
                if(now.cd < bestd){
                    q.push(now); 
                }
            }
        }
        if(q.empty())
            break;
        else
            q.delete(enode);  //下一层扩展结点
    }
    return bestd;
}
```

#### 6-2 最小权顶点覆盖问题

##### 问题表达

此问题为固定无和子集个数$n$搜索最大$n$可分的$k$值。对于一个特定的$k$，由题知集合$\{1, 2, 3,...,k\}$是$n$可分的。令解向量$\vec x=(x_1, x_2, x_3...,x_n)$表示为$n$个无和集，其中$x_i$表示第$i$个无和集。对于$1$到$k$的正整数，要将每一个元素无重复地分配到$n$个子集，即解空间为子集树。

##### 剪枝条件

###### 可行性约束

对于搜索到当前节点的第$i$个节点，表示将第$i$个节点的深度$d$放入$x_i$子集中，如果$x_i$存在两个元素相加为$d$，则要进行剪枝。

###### 边界约束

对于当前节点的子节点深度为$d+1$，如果遍历所有子节点均无法将$d+1$加入，即$d+1$无法构成$n$可分的无和子集，则$F(n)$找到，值为$d$，停止搜索。

##### 时间复杂度

由于此解空间为子集树，对于每个深度均有$n$个节点，共有深度为$k$，即最大节点数有$k^n$个，由于判断可行性约束需要$O(k^2)$，即总时间复杂度为$O(k^{(n+2)})$。

##### 伪代码

```C++
int F[N][N],answer[N][N];
int n,maxValue; 

int judge(int t,int k){
	int i,j;
	for(i=1;i<=F[k][0];i++){
		for(j=i+1;j<=F[k][0];j++){
			if(F[k][i]+F[k][j]==t)
			   return 0;
		}
	}
	return 1;	
}

void search(int t){
	int i,j;
	if(t>maxValue){//边界约束
		for(i=0;i<n;i++){
			for(j=0;j<=F[i][0];j++){  
				answer[i][j] = F[i][j];
			}
		}
		maxValue = t;
	}
	
	for(i=0;i<n;i++){
		F[i][F[i][0]+1]=t;
		if(judge(t,i)){//可行性约束
			F[i][0]+=1;
			search(t+1);
			F[i][0]-=1;
		}
	} 
} 
```

#### 5-16 工作分配问题

##### 问题表达

此问题解空间为排列树，设解向量$\vec x=(x_1, x_2, ..., n)$表示第$i$个工作被分配给$x_i$工人，$x_i\in\{1, 2, 3,...,n\}$。

##### 剪枝条件

###### 可行性约束

$x_i\in\{1, 2, 3,...,n\}$。

###### 边界约束

假设分配到第$k$个工作，则已知花费$C_k=\sum_i c[i][x_i]$，对于已知最优花费$C_{best}$，如果$C_k>C_{best}$，则需要剪枝，如果搜索到第$n$个工作，则需将结果返回。

##### 时间复杂度

由于子问题共有$n!$个，每次计算需要$O(n)$，即最差时间复杂度为$O(n*n!)$。

##### 伪代码

```C++
int compute(int k)//计算前k个花费
{
    int temp=0,i;
    for(i=1;i<=k;i++)
        temp+=table[i][r[i]];
    return temp;
}

void search(int k)
{
    if(k==n)//叶节点
    {
        int temp=compute(n);
        if(temp<best)
            best=temp;
        return;
    }
    for(int i=k;i<=n;i++)
    {
        swap(r[i],r[k]);
        if(compute(k) < best)//剪枝函数
            search(k+1);
        swap(r[i],r[k]);
    }
}
```



### <center>三、算法实现题</center>

#### 5-9 拉丁矩阵问题

##### 问题表达

此问题求矩阵$m*n$对于$n$的排列，即解空间为排列树。令解向量为$a[m][n]$，$a[i][j]$表示为第$i$行第$j$列宝石形状，$a[i][j]\in\{1, 2, 3, ..., n\}$。

##### 剪枝条件

###### 可行性约束

由于题目要求各行各列形状不同，即对于搜索到$a[x][y]$，$\exists i,m<x,j,n<y,\ a[i][j]==a[m][n]$，违反可行性条件，则需要剪枝。

###### 边界约束

由于此题不需要对满足问题的解有要求，则只需在搜索到叶节点即可返回，停止回溯。

##### 时间复杂度

对于解集空间最大共有$m*A_n^m$个子问题，每个子问题要判断是否满足可行性约束需要$O(n)$，即最差时间复杂度为$O(m*n*A_n^m)$。

##### 代码

见附件，直接在附件文件夹运行$latin\_maxtrix.exe$即可。